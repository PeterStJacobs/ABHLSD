<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mars–Venus: Angle, Distance + Angle↔Distance</title>
<style>
  :root { --bg:#0b1020; --panel:#171c2e; --text:#e8ecff; --muted:#9aa3c7; --accent:#7aa2ff; --border:#2b3252; }

  *, *::before, *::after { box-sizing: border-box; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
  h1{margin:0 0 8px;font-size:clamp(24px,3.6vw,36px)}
  p.lead{color:var(--muted);margin:0 0 16px}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}

  .grid{display:grid;gap:16px;grid-template-columns:1fr}
  @media (min-width:900px){
    .grid.two   { grid-template-columns: minmax(0,1fr) minmax(0,1fr); }
    .grid.three { grid-template-columns: minmax(0,1fr) minmax(0,1fr) minmax(0,1fr); }
  }
  .span-all { grid-column: 1 / -1; }

  label{display:block;font-weight:600;margin-bottom:6px}
  input[type="datetime-local"],input[type="number"],select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#0f1426;color:var(--text)}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .buttons{display:flex;gap:10px;flex-wrap:wrap}
  button{background:var(--accent);color:#0a0f1e;font-weight:700;border:none;padding:10px 14px;border-radius:12px;cursor:pointer}
  button.secondary{background:#2b3252;color:var(--text)}
  .results{display:grid;grid-template-columns:1fr;gap:12px}
  .btn-back { pointer-events: auto; position: relative; z-index: 10; }
  @media (min-width:700px){.results{grid-template-columns:1fr 1fr}}
  .tile{background:#10162a;border:1px solid var(--border);border-radius:12px;padding:14px}
  .k{color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.08em}
  .v{font-size:clamp(18px,3vw,28px);font-variant-numeric:tabular-nums}
  .sub{color:var(--muted);margin-top:6px;font-size:14px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;white-space:pre-wrap}
  .error{color:#ffb3b3;margin-top:8px}
  canvas{width:100%;height:260px;background:#0f1426;border:1px solid var(--border);border-radius:12px;display:block}
  .small{font-size:12px;color:var(--muted)}
  .checkrow{display:flex;gap:10px;align-items:center;margin-top:8px}

  #dt { max-width: 380px; }

  .tip{position:relative;display:inline-flex;align-items:center}
  .tip-btn{background:#2b3252;border:1px solid var(--border);color:#e8ecff;width:18px;height:18px;border-radius:50%;
           font-size:12px;line-height:16px;text-align:center;cursor:help;user-select:none}
  .tip-content{position:absolute;left:26px;top:-2px;display:none;width:320px;background:#10162a;border:1px solid var(--border);
               color:var(--text);padding:10px 12px;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,.4);z-index:20}
  .tip:focus-within .tip-content, .tip:hover .tip-content{display:block}
  .tip-content p{margin:0 0 6px 0;font-size:13px;color:#cbd3f5}
  .tip-content ul{margin:0 0 0 18px;padding:0;font-size:13px;color:#cbd3f5}
  .tip-content li{margin:2px 0}

  /* Legend colours for angle + current time */
  .legend .min { color:#3bd16f; font-weight:600; }
  .legend .max { color:#ff7272; font-weight:600; }
  .legend .now { color:#6aa7ff; font-weight:600; }

  /* Distance legend colours (global classes) */
  .min-dist { color:#1e8f5a; font-weight:600; }
  .max-dist { color:#b22222; font-weight:600; }

  /* Scan text colours */
  .min-line { color:#3bd16f; font-weight:600; }
  .max-line { color:#ff7272; font-weight:600; }
  .min-dist-line { color:#1e8f5a; font-weight:600; }
  .max-dist-line { color:#b22222; font-weight:600; }

  /* Back button */
  .topbar { display:flex; align-items:center; margin-bottom:8px; }
  .back {
    background:#2b3252;
    color:var(--text);
    font-weight:700;
    padding:8px 12px;
    border-radius:10px;
    text-decoration:none;
    border:1px solid var(--border);
    display:inline-flex; gap:6px; align-items:center;
  }
  .back:hover { filter:brightness(1.05); }

  /* Sticky top pane (title + first card) */
  .sticky-pane {
    position: sticky;
    top: 0;
    z-index: 100;
    background: linear-gradient(180deg, rgba(11,16,32,0.98), rgba(11,16,32,0.98));
    padding-top: 6px;
    margin-bottom: 12px;
    backdrop-filter: blur(6px);
    border-bottom: 1px solid var(--border);
  }
  @media (max-width: 820px), (max-height: 720px) {
    .sticky-pane { position: static; backdrop-filter:none; border-bottom:none; }
  }

  /* Angle–Distance legend styling */
  .legend-scatter { text-align:center; margin-top:6px; color:var(--muted); font-size:13px; }
  .swatch{display:inline-block; width:10px; height:10px; border-radius:50%; margin:0 6px -1px 8px; vertical-align:middle; border:1px solid #0003;}
  .sw-now{ background:#6aa7ff; }
  .sw-path{ background:#7aa2ff; }
  .sw-grad-a{ background:#6aa7ff; }
  .sw-grad-b{ background:#ff86c8; }
  .sw-min{ background:#3bd16f; }
  .sw-max{ background:#ff7272; }
  .sw-mind{ background:#1e8f5a; }
  .sw-maxd{ background:#b22222; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">

<!-- file:///C:/Users/Martin/Downloads/ABHLSD/index.html 	-->
<!--	<a href="../index.html">Back to ABHLSD</a>		-->
	<a id="backLink" class="btn-back" href="../index.html" aria-label="Back to ABHLSD">← Back to ABHLSD</a>
    </div>

    <!-- STICKY PANE: title + main controls -->
    <div class="sticky-pane">
      <h1>Mars–Venus: Angular Separation & Planet–Planet Distance</h1>
      <p class="lead">Local calculations via astronomy-engine. Toggle topocentric angle (location-dependent). Presets + elevation + current location. Time charts honor the timezone toggle; the Angle–Distance chart has its own legend below.</p>

      <div class="card">
        <div class="grid two">
          <div>
            <label for="dt">Date & time (local)</label>
            <input id="dt" type="datetime-local" />
            <div class="buttons" style="margin-top:10px;">
              <button id="btn-now" type="button">Use current time</button>
              <button id="btn-calc" type="button">Calculate</button>
            </div>

            <div class="checkrow">
              <input id="chk-topo" type="checkbox" />
              <label for="chk-topo" style="margin:0;">Use topocentric angle (location-dependent)</label>
              <span class="tip">
                <button class="tip-btn" aria-label="What does topocentric mean?" aria-describedby="tip-topo">?</button>
                <div id="tip-topo" role="tooltip" class="tip-content">
                  <p><strong>Geocentric</strong> angle: from Earth’s center (default). Same for all locations.</p>
                  <p><strong>Topocentric</strong> angle: from your site (includes parallax). Can differ slightly by location.</p>
                  <ul>
                    <li>Effect size (planets): typically a few to a few tens of arcseconds (~0.01°).</li>
                    <li>Plots, scan and CSV use whichever mode is selected.</li>
                  </ul>
                </div>
              </span>
            </div>

            <!-- Timezone toggle -->
            <div class="checkrow">
              <input id="chk-use-obs-tz" type="checkbox" checked />
              <label for="chk-use-obs-tz" style="margin:0;">Use observer timezone for time charts (otherwise UTC)</label>
            </div>

            <!-- Options for Angle–Distance chart -->
            <div class="checkrow">
              <input id="chk-time-arrows" type="checkbox" />
              <label for="chk-time-arrows" style="margin:0;">Show time arrows on Angle–Distance plot</label>
            </div>
            <div class="checkrow">
              <input id="chk-time-gradient" type="checkbox" />
              <label for="chk-time-gradient" style="margin:0;">Color Angle–Distance path by time (early→late)</label>
            </div>

            <div id="err" class="error" role="alert" aria-live="polite"></div>
            <p class="small">Angle uses geocentric (checkbox off) or topocentric (checkbox on). Distance is heliocentric; Alt/Az readouts are topocentric.</p>
          </div>
          <div>
            <div class="results">
              <div class="tile">
                <div class="k">Angular separation</div>
                <div class="v" id="angle">—</div>
                <div class="sub mono" id="angle-sub">—</div>
              </div>
              <div class="tile">
                <div class="k">Planet–planet distance</div>
                <div class="v" id="dist-au">—</div>
                <div class="sub mono" id="dist-km">—</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div><!-- /sticky-pane -->

    <!-- Planet readouts -->
    <div class="grid two" style="margin-top:16px;">
      <div class="card">
        <div class="k">Mars (geocentric apparent)</div>
        <div class="v mono" id="mars-radec">—</div>
        <div class="sub mono" id="mars-xyz">—</div>
        <div class="sub mono" id="mars-horiz">—</div>
      </div>
      <div class="card">
        <div class="k">Venus (geocentric apparent)</div>
        <div class="v mono" id="venus-radec">—</div>
        <div class="sub mono" id="venus-xyz">—</div>
        <div class="sub mono" id="venus-horiz">—</div>
      </div>
    </div>

    <!-- SETTINGS -->
    <div class="card" style="margin-top:16px;">
      <div class="grid three">
        <div class="span-all">
          <label>Location preset</label>
          <select id="preset">
            <option value="brisbane" selected>Brisbane, QLD, AU (-27.4698, 153.0251, 50 m)</option>
            <option value="phoenix">Phoenix, AZ, USA (33.4484, -112.0740, 331 m)</option>
            <option value="kincardine">Kincardine, ON, CA (44.1838, -81.6384, auto)</option>
            <option value="waterloo">Waterloo, ON, CA (43.4732, -80.5359, auto)</option>
            <option value="scottsdale">Scottsdale, AZ, USA (33.6372, -111.9248, auto)</option>
            <option value="toronto">Toronto, ON, CA (43.6460, -79.3814, auto)</option>
            <option value="custom">Custom (use fields below)</option>
          </select>
        </div>

        <div>
          <label>Observer latitude (deg)</label>
          <input id="lat" type="number" step="0.0001" value="-27.4698" />
        </div>
        <div>
          <label>Observer longitude (deg)</label>
          <input id="lon" type="number" step="0.0001" value="153.0251" />
        </div>
        <div>
          <label>Elevation (m)</label>
          <input id="elev" type="number" step="1" value="50" />
        </div>

        <div class="span-all">
          <div class="buttons">
            <button id="btn-update-observer" class="secondary" type="button">Update observer</button>
            <button id="btn-fetch-elev" class="secondary" type="button" title="Lookup elevation by lat/lon">Fetch elevation</button>
            <button id="btn-my-location" class="secondary" type="button" title="Use device GPS">Use current location</button>
          </div>
        </div>
      </div>
      <p class="small">Presets marked "auto" fetch elevation from Open-Meteo. "Use current location" asks your browser for GPS, then fetches elevation too.</p>
    </div>

    <!-- SCAN / PLOT -->
    <div class="card" style="margin-top:16px;">
      <div class="row" style="gap:16px;">
        <div>
          <label>Scan window (days, +/- around selected time)</label>
          <input id="scan-days" type="number" step="1" value="30" />
        </div>
        <div>
          <label>Step size (hours)</label>
          <input id="scan-step" type="number" step="1" value="6" />
        </div>
        <div class="buttons" style="align-self:flex-end;">
          <button id="btn-scan" type="button">Find closest & greatest</button>
          <button id="btn-plot" class="secondary" type="button">Plot angle & distance</button>
          <button id="btn-download-csv" class="secondary" type="button">Download CSV</button>
          <button id="btn-save-png" class="secondary" type="button">Save charts as PNG</button>
        </div>
      </div>

      <div id="scan-results" class="mono" style="margin-top:10px;">—</div>

      <div class="grid two" style="margin-top:12px;">
        <div>
          <div class="k" style="margin-bottom:6px;">Angular separation (deg) vs time</div>
          <canvas id="chart-angle" width="500" height="260"></canvas>
        </div>
        <div>
          <div class="k" style="margin-bottom:6px;">Distance (AU) vs time</div>
          <canvas id="chart-dist" width="500" height="260"></canvas>
        </div>
      </div>

      <!-- LEGEND pinned immediately below the first two charts -->
      <div class="legend" id="legend-time" style="text-align:center; margin-top:6px;"></div>

      <!-- Third chart -->
      <div style="margin-top:14px;">
        <div class="k" style="margin-bottom:6px;">Angle (deg) vs Distance (AU)</div>
        <canvas id="chart-angle-dist" width="1024" height="260"></canvas>
        <div id="legend-scatter" class="legend-scatter"></div>
      </div>
    </div>

    <p class="small" style="margin-top:16px;">To publish, upload this file and <code>astronomy.browser.min.js</code> to your hosting.</p>
  </div>

  <script src="./astronomy.browser.min.js"></script>

  <script>
  (function(){
    /* ----------------- Small helpers & constants ----------------- */
    const $ = (id) => document.getElementById(id);
    const setErr = (msg) => { $('err').textContent = msg || ''; };
    const AU_KM = 149597870.7;

    const pad = (n, w=2) => String(n).padStart(w,'0');
    function fmtRA(hours){
      const s = hours * 3600;
      const h = Math.floor(s/3600);
      const m = Math.floor((s % 3600) / 60);
      const sec = s % 60;
      return `${pad(h)}h ${pad(m)}m ${sec.toFixed(2)}s`;
    }
    function fmtDec(deg){
      const sign = deg < 0 ? '-' : '+';
      const d = Math.abs(deg);
      const D = Math.floor(d);
      const M = Math.floor((d - D) * 60);
      const S = (d - D - M/60) * 3600;
      return `${sign}${pad(D)} deg ${pad(M)} min ${S.toFixed(1)} sec`;
    }
    function fmtAngleDMS(deg){
      const d = Math.abs(deg);
      const D = Math.floor(d);
      const M = Math.floor((d - D) * 60);
      const S = (d - D - M/60) * 3600;
      return `${D} deg ${M} min ${S.toFixed(1)} sec`;
    }
    function fmtAU(au){
      return au.toLocaleString(undefined,{minimumFractionDigits:6,maximumFractionDigits:6})+' AU';
    }
    function fmtKM(km){
      return km.toLocaleString(undefined,{maximumFractionDigits:0})+' km';
    }
    function fmtInTz(iso, tz){
      const d = new Date(iso);
      return d.toLocaleString(undefined,{
        year:'numeric', month:'2-digit', day:'2-digit',
        hour:'2-digit', minute:'2-digit', second:'2-digit',
        hour12:false, timeZone: tz, timeZoneName:'short'
      }).replace(',', '');
    }
    function setNow(){
      const dt=$('dt'), now=new Date();
      const isoLocal=new Date(now.getTime()-now.getTimezoneOffset()*60000).toISOString().slice(0,16);
      dt.value=isoLocal;
    }

    /* ----------------- Colors & legends ----------------- */
    const CLR_MIN = '#3bd16f';     // angle min (bright green)
    const CLR_MAX = '#ff7272';     // angle max (bright red)
    const CLR_NOW = '#6aa7ff';     // current time (blue)
    const CLR_MIN_DIST = '#1e8f5a'; // distance min (dark green)
    const CLR_MAX_DIST = '#b22222'; // distance max (dark red)
    const CLR_TIME_EARLY = '#6aa7ff'; // scatter gradient start
    const CLR_TIME_LATE  = '#ff86c8'; // scatter gradient end

    function setLegendTime(){
      $('legend-time').innerHTML =
        'Angle: <span class="min">Min</span>, <span class="max">Max</span> &nbsp;|&nbsp; ' +
        'Distance: <span class="min-dist">Min</span>, <span class="max-dist">Max</span> &nbsp;|&nbsp; ' +
        '<span class="now">Current Time</span>';
    }
    function setLegendScatter(){
      const gradientOn = $('chk-time-gradient')?.checked;
      $('legend-scatter').innerHTML =
        '<span class="swatch sw-path"></span> Path (time order)'
        + (gradientOn
          ? ' &nbsp;→ colored by time: <span class="swatch sw-grad-a"></span> early to <span class="swatch sw-grad-b"></span> late'
          : ' (solid blue)')
        + ' &nbsp;|&nbsp; arrows show forward time (if enabled)'
        + ' &nbsp;|&nbsp; markers: '
        + '<span class="swatch sw-now"></span> current time, '
        + '<span class="swatch sw-min"></span> min angle, '
        + '<span class="swatch sw-max"></span> max angle, '
        + '<span class="swatch sw-mind"></span> min distance, '
        + '<span class="swatch sw-maxd"></span> max distance';
    }

    /* ----------------- Time tick labelling (UTC vs observer TZ) ----------------- */
    let observerTz = null;
    let observerTzLabel = '';
    function tickPartsInZone(ms, tz){
      const d = new Date(ms);
      const fmt = new Intl.DateTimeFormat(undefined, {
        timeZone: tz, year:'2-digit', month:'2-digit', day:'2-digit',
        hour:'2-digit', minute:'2-digit', hour12:false
      });
      const parts = fmt.formatToParts(d);
      const get = (t) => (parts.find(p=>p.type===t)||{}).value || '';
      return [`${get('year')}-${get('month')}-${get('day')}`, `${get('hour')}:${get('minute')}`];
    }
    function useObserverTz(){ return $('chk-use-obs-tz')?.checked; }
    function tickPartsForMode(ms){
      const tz = useObserverTz() ? (observerTz || Intl.DateTimeFormat().resolvedOptions().timeZone) : 'UTC';
      return tickPartsInZone(ms, tz);
    }

    /* ----------------- Presets & observer ----------------- */
    const PRESETS = {
      brisbane:   { lat:-27.4698,     lon: 153.0251,      elev: 50  },
      phoenix:    { lat: 33.4484,     lon:-112.0740,      elev: 331 },
      kincardine: { lat: 44.1838078,  lon: -81.6384156,   elev: 'auto' },
      waterloo:   { lat: 43.47321866, lon: -80.53587863,  elev: 'auto' },
      scottsdale: { lat: 33.63719972, lon:-111.92482642,  elev: 'auto' },
      toronto:    { lat: 43.64603472, lon: -79.38138754,  elev: 'auto' }
    };
    let observer = null;

    function updateObserverFromInputs(){
      try {
        const lat  = parseFloat($('lat').value);
        const lon  = parseFloat($('lon').value);
        let elev = parseFloat($('elev').value);
        if (!Number.isFinite(elev)) elev = 0;
        observer = new Astronomy.Observer(lat, lon, elev);
      } catch(e){ setErr('Invalid observer values: ' + e.message); }
    }

    async function fetchTimezoneForInputs(silent=true){
      const lat = parseFloat($('lat').value);
      const lon = parseFloat($('lon').value);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)){
        if (!silent) setErr('Enter valid latitude and longitude for timezone lookup.');
        return;
      }
      try{
        const url = 'https://api.geotimezone.com/public/timezone?latitude='+encodeURIComponent(lat)+'&longitude='+encodeURIComponent(lon);
        const resp = await fetch(url);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data && data.iana_timezone){
          observerTz = data.iana_timezone;
          observerTzLabel = observerTz;
        } else {
          throw new Error('No IANA timezone in response');
        }
      } catch(e){
        observerTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
        observerTzLabel = observerTz + ' (browser fallback)';
        if (!silent) setErr('Timezone lookup failed; using browser timezone.');
      }
    }

    function setInputsFromPreset(name){
      const p = PRESETS[name]; if (!p) return;
      $('lat').value  = p.lat;
      $('lon').value  = p.lon;
      if (p.elev === 'auto'){
        $('elev').value = '';
        fetchElevationForInputs(true);
      } else {
        $('elev').value = p.elev;
      }
      updateObserverFromInputs();
      fetchTimezoneForInputs(true);
      compute();
    }

    /* ----------------- Core astronomy helpers ----------------- */
    function vecToRaDec(v){
      const rxy = Math.hypot(v.x, v.y);
      let ra = Math.atan2(v.y, v.x); if (ra < 0) ra += 2*Math.PI;
      const dec = Math.atan2(v.z, rxy);
      return { raHours: ra * 12/Math.PI, decDeg: dec * 180/Math.PI };
    }
    function angleFromRaDec(ra1h, dec1d, ra2h, dec2d){
      const ra1 = ra1h * Math.PI/12;
      const ra2 = ra2h * Math.PI/12;
      const d1  = dec1d * Math.PI/180;
      const d2  = dec2d * Math.PI/180;
      const x1 = Math.cos(d1)*Math.cos(ra1), y1 = Math.cos(d1)*Math.sin(ra1), z1 = Math.sin(d1);
      const x2 = Math.cos(d2)*Math.cos(ra2), y2 = Math.cos(d2)*Math.sin(ra2), z2 = Math.sin(2);
      // ^^^ OOPS! Fix typo: Math.sin(2) would be wrong — correct below:
    }
  })();
  </script>

  <!-- ======= IMPORTANT: The script above continues below; split only for readability ======= -->
  <script>
  (function(){
    const $ = (id) => document.getElementById(id);
    const AU_KM = 149597870.7;
    const CLR_MIN = '#3bd16f', CLR_MAX = '#ff7272', CLR_NOW = '#6aa7ff', CLR_MIN_DIST = '#1e8f5a', CLR_MAX_DIST = '#b22222';
    const CLR_TIME_EARLY = '#6aa7ff', CLR_TIME_LATE = '#ff86c8';
    let observer = null, observerTz=null, observerTzLabel='', lastMarkers=null;

    /* Re-declare only what's needed from previous block (self-contained page build) */
    const setErr = (m)=>{ const el=$('err'); if(el) el.textContent=m||''; };
    const pad = (n,w=2)=>String(n).padStart(w,'0');
    function fmtRA(h){const s=h*3600,H=Math.floor(s/3600),M=Math.floor((s%3600)/60),S=s%60;return `${pad(H)}h ${pad(M)}m ${S.toFixed(2)}s`;}
    function fmtDec(deg){const sign=deg<0?'-':'+';const d=Math.abs(deg),D=Math.floor(d),M=Math.floor((d-D)*60),S=(d-D-M/60)*3600;return `${sign}${pad(D)} deg ${pad(M)} min ${S.toFixed(1)} sec`;}
    function fmtAngleDMS(deg){const d=Math.abs(deg),D=Math.floor(d),M=Math.floor((d-D)*60),S=(d-D-M/60)*3600;return `${D} deg ${M} min ${S.toFixed(1)} sec`;}
    function fmtAU(au){return au.toLocaleString(undefined,{minimumFractionDigits:6,maximumFractionDigits:6})+' AU';}
    function fmtKM(km){return km.toLocaleString(undefined,{maximumFractionDigits:0})+' km';}
    function fmtInTz(iso,tz){const d=new Date(iso);return d.toLocaleString(undefined,{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false,timeZone:tz,timeZoneName:'short'}).replace(',','');}
    function setNow(){const dt=$('dt'),now=new Date();const isoLocal=new Date(now.getTime()-now.getTimezoneOffset()*60000).toISOString().slice(0,16);dt.value=isoLocal;}
    function tickPartsInZone(ms,tz){const d=new Date(ms);const fmt=new Intl.DateTimeFormat(undefined,{timeZone:tz,year:'2-digit',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',hour12:false});const parts=fmt.formatToParts(d);const get=(t)=>(parts.find(p=>p.type===t)||{}).value||'';return [`${get('year')}-${get('month')}-${get('day')}`,`${get('hour')}:${get('minute')}`];}
    function useObserverTz(){return $('chk-use-obs-tz')?.checked;}
    function tickPartsForMode(ms){const tz=useObserverTz()?(observerTz||Intl.DateTimeFormat().resolvedOptions().timeZone):'UTC';return tickPartsInZone(ms,tz);}
    const PRESETS={brisbane:{lat:-27.4698,lon:153.0251,elev:50},phoenix:{lat:33.4484,lon:-112.0740,elev:331},kincardine:{lat:44.1838078,lon:-81.6384156,elev:'auto'},waterloo:{lat:43.47321866,lon:-80.53587863,elev:'auto'},scottsdale:{lat:33.63719972,lon:-111.92482642,elev:'auto'},toronto:{lat:43.64603472,lon:-79.38138754,elev:'auto'}};

    function updateObserverFromInputs(){try{const lat=parseFloat($('lat').value);const lon=parseFloat($('lon').value);let elev=parseFloat($('elev').value);if(!Number.isFinite(elev))elev=0;observer=new Astronomy.Observer(lat,lon,elev);}catch(e){setErr('Invalid observer values: '+e.message);}}
    async function fetchTimezoneForInputs(silent=true){const lat=parseFloat($('lat').value);const lon=parseFloat($('lon').value);if(!Number.isFinite(lat)||!Number.isFinite(lon)){if(!silent)setErr('Enter valid latitude/longitude for timezone lookup.');return;}try{const url='https://api.geotimezone.com/public/timezone?latitude='+encodeURIComponent(lat)+'&longitude='+encodeURIComponent(lon);const resp=await fetch(url);if(!resp.ok)throw new Error('HTTP '+resp.status);const data=await resp.json();if(data&&data.iana_timezone){observerTz=data.iana_timezone;observerTzLabel=observerTz;}else{throw new Error('No IANA timezone in response');}}catch(e){observerTz=Intl.DateTimeFormat().resolvedOptions().timeZone;observerTzLabel=observerTz+' (browser fallback)';if(!silent)setErr('Timezone lookup failed; using browser timezone.');}}
    function setInputsFromPreset(name){const p=PRESETS[name];if(!p)return;$('lat').value=p.lat;$('lon').value=p.lon;if(p.elev==='auto'){$('elev').value='';fetchElevationForInputs(true);}else{$('elev').value=p.elev;}updateObserverFromInputs();fetchTimezoneForInputs(true);compute();}

    function vecToRaDec(v){const rxy=Math.hypot(v.x,v.y);let ra=Math.atan2(v.y,v.x);if(ra<0)ra+=2*Math.PI;const dec=Math.atan2(v.z,rxy);return{raHours:ra*12/Math.PI,decDeg:dec*180/Math.PI};}
    function angleFromRaDec(ra1h,dec1d,ra2h,dec2d){const ra1=ra1h*Math.PI/12,ra2=ra2h*Math.PI/12,d1=dec1d*Math.PI/180,d2=dec2d*Math.PI/180;const x1=Math.cos(d1)*Math.cos(ra1),y1=Math.cos(d1)*Math.sin(ra1),z1=Math.sin(d1);const x2=Math.cos(d2)*Math.cos(ra2),y2=Math.cos(d2)*Math.sin(ra2),z2=Math.sin(d2);const dot=Math.max(-1,Math.min(1,x1*x2+y1*y2+z1*z2));return Math.acos(dot)*180/Math.PI;}
    function angleAtTime(t,useTopocentric){const A=window.Astronomy;if(!useTopocentric){const gvM=A.GeoVector(A.Body.Mars,t,true);const gvV=A.GeoVector(A.Body.Venus,t,true);return A.AngleBetween(gvM,gvV);}else{const eqM=A.Equator(A.Body.Mars,t,observer,true,true);const eqV=A.Equator(A.Body.Venus,t,observer,true,true);return angleFromRaDec(eqM.ra,eqM.dec,eqV.ra,eqV.dec);}}
    function distanceAtTime(t){const A=window.Astronomy;const hvM=A.HelioVector(A.Body.Mars,t);const hvV=A.HelioVector(A.Body.Venus,t);return Math.hypot(hvM.x-hvV.x,hvM.y-hvV.y,hvM.z-hvV.z);}

    function compute(){
      setErr('');
      if(typeof window.Astronomy==='undefined'){setErr('astronomy.browser.min.js did not load.');return;}
      if(!observer) updateObserverFromInputs();
      const A=window.Astronomy;
      const useTopo=$('chk-topo').checked;
      const dtInput=$('dt').value;
      const date=dtInput?new Date(dtInput):new Date();
      const t=new A.AstroTime(date);

      const angDeg=angleAtTime(t,useTopo);
      const gvM=A.GeoVector(A.Body.Mars,t,true);
      const gvV=A.GeoVector(A.Body.Venus,t,true);
      const m=vecToRaDec(gvM), v=vecToRaDec(gvV);
      const dAU=distanceAtTime(t), dKM=dAU*AU_KM;

      let horM=null,horV=null;
      try{
        const eqMars=A.Equator(A.Body.Mars,t,observer,true,true);
        const eqVenus=A.Equator(A.Body.Venus,t,observer,true,true);
        horM=A.Horizon(t,observer,eqMars.ra,eqMars.dec,'normal');
        horV=A.Horizon(t,observer,eqVenus.ra,eqVenus.dec,'normal');
      }catch(e){}

      $('angle').textContent=fmtAngleDMS(angDeg);
      $('angle-sub').textContent=angDeg.toFixed(6)+' deg ('+(useTopo?'topocentric':'geocentric')+')';
      $('dist-au').textContent=fmtAU(dAU);
      $('dist-km').textContent=fmtKM(dKM);
      $('mars-radec').textContent='RA '+fmtRA(m.raHours)+',  Dec '+fmtDec(m.decDeg);
      $('venus-radec').textContent='RA '+fmtRA(v.raHours)+', Dec '+fmtDec(v.decDeg);

      const hvM=A.HelioVector(A.Body.Mars,t);
      const hvV=A.HelioVector(A.Body.Venus,t);
      $('mars-xyz').textContent='Heliocentric: x='+hvM.x.toFixed(6)+', y='+hvM.y.toFixed(6)+', z='+hvM.z.toFixed(6)+' AU';
      $('venus-xyz').textContent='Heliocentric: x='+hvV.x.toFixed(6)+', y='+hvV.y.toFixed(6)+', z='+hvV.z.toFixed(6)+' AU';

      $('mars-horiz').textContent=horM?('Topocentric Alt='+(horM.altitude.toFixed(1))+' deg, Az='+(horM.azimuth.toFixed(1))+' deg'):'Topocentric Alt/Az unavailable.';
      $('venus-horiz').textContent=horV?('Topocentric Alt='+(horV.altitude.toFixed(1))+' deg, Az='+(horV.azimuth.toFixed(1))+' deg'):'Topocentric Alt/Az unavailable.';
    }

    async function scanExtrema(centerDate,days,stepHours,useTopo){
      const A=window.Astronomy;
      let bestMinA={t:null,val:Infinity},bestMaxA={t:null,val:-Infinity};
      let bestMinD={t:null,val:Infinity},bestMaxD={t:null,val:-Infinity};
      for(let h=-days*24;h<=days*24;h+=stepHours){
        const t=new A.AstroTime(new Date(centerDate.getTime()+h*3600*1000));
        const a=angleAtTime(t,useTopo);
        const d=distanceAtTime(t);
        if(a<bestMinA.val)bestMinA={t,val:a};
        if(a>bestMaxA.val)bestMaxA={t,val:a};
        if(d<bestMinD.val)bestMinD={t,val:d};
        if(d>bestMaxD.val)bestMaxD={t,val:d};
      }
      async function refine(t0,mode,f){
        let center=t0.date.getTime();
        const steps=[3600e3,600e3,60e3,10e3];
        for(const step of steps){
          let best={t:center,val:(mode==='min'?Infinity:-Infinity)};
          for(let k=-5;k<=5;k++){
            const tt=center+k*step;
            const val=f(new A.AstroTime(new Date(tt)));
            if((mode==='min'&&val<best.val)||(mode==='max'&&val>best.val)){best={t:tt,val};}
          }
          center=best.t;
        }
        return new A.AstroTime(new Date(center));
      }
      const minAT=await refine(bestMinA.t,'min',(tt)=>angleAtTime(tt,useTopo));
      const maxAT=await refine(bestMaxA.t,'max',(tt)=>angleAtTime(tt,useTopo));
      const minDT=await refine(bestMinD.t,'min',(tt)=>distanceAtTime(tt));
      const maxDT=await refine(bestMaxD.t,'max',(tt)=>distanceAtTime(tt));
      return{
        minAngle:{time:minAT.date.toISOString(),deg:angleAtTime(minAT,useTopo)},
        maxAngle:{time:maxAT.date.toISOString(),deg:angleAtTime(maxAT,useTopo)},
        minDistance:{time:minDT.date.toISOString(),au:distanceAtTime(minDT),km:distanceAtTime(minDT)*AU_KM},
        maxDistance:{time:maxDT.date.toISOString(),au:distanceAtTime(maxDT),km:distanceAtTime(maxDT)*AU_KM}
      };
    }

    function collectSeries(centerDate,days,stepHours,useTopo){
      const A=window.Astronomy;
      const xs=[],angle=[],dist=[];
      for(let h=-days*24;h<=days*24;h+=stepHours){
        const d=new Date(centerDate.getTime()+h*3600*1000);
        const t=new A.AstroTime(d);
        xs.push(d.getTime());
        angle.push(angleAtTime(t,useTopo));
        dist.push(distanceAtTime(t));
      }
      return { xs, angle, dist };
    }

    /* ----------------- Plotting ----------------- */
    function plotSeries(canvas,xs,ys,yLabel,markers){
      const ctx=canvas.getContext('2d'); const W=canvas.width,H=canvas.height;
      ctx.clearRect(0,0,W,H);
      const P_LEFT=48,P_RIGHT=16,P_TOP=20,P_BOTTOM=72;
      const x0=P_LEFT,y0=H-P_BOTTOM,x1=W-P_RIGHT,y1=P_TOP;

      ctx.strokeStyle='#3a4367';ctx.lineWidth=1;
      ctx.beginPath();ctx.moveTo(x0,y0);ctx.lineTo(x1,y0);ctx.moveTo(x0,y0);ctx.lineTo(x0,y1);ctx.stroke();

      ctx.fillStyle='#9aa3c7';ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';ctx.fillText(yLabel,x0,y1-6);

      const xmin=Math.min(...xs),xmax=Math.max(...xs);
      const ymin=Math.min(...ys),ymax=Math.max(...ys);
      const xr=xmax-xmin||1,yr=ymax-ymin||1;
      const xmap=(x)=>x0+(x-xmin)/xr*(x1-x0);
      const ymap=(y)=>y0-(y-ymin)/yr*(y0-y1);

      ctx.strokeStyle='#25304f';ctx.setLineDash([3,3]);
      for(let i=1;i<=4;i++){const yy=y0-i*(y0-y1)/5;ctx.beginPath();ctx.moveTo(x0,yy);ctx.lineTo(x1,yy);ctx.stroke();}
      ctx.setLineDash([]);

      ctx.strokeStyle='#7aa2ff';ctx.lineWidth=2;ctx.beginPath();
      ys.forEach((y,i)=>{const xx=xmap(xs[i]),yy=ymap(y);if(i===0)ctx.moveTo(xx,yy);else ctx.lineTo(xx,yy);});
      ctx.stroke();

      if(markers&&markers.length){
        markers.forEach(m=>{
          if(m.t<xmin||m.t>xmax)return;
          const xx=xmap(m.t);
          ctx.save();ctx.strokeStyle=m.color;ctx.lineWidth=1.5;ctx.setLineDash([]);
          ctx.beginPath();ctx.moveTo(xx,y0);ctx.lineTo(xx,y1);ctx.stroke();ctx.restore();
        });
      }

      const px=x1-x0;const tickCount=Math.min(10,Math.max(4,Math.floor(px/110)));
      ctx.fillStyle='#9aa3c7';ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';
      for(let i=0;i<=tickCount;i++){
        const t=xmin+i*(xr/tickCount);const xx=xmap(t);
        ctx.strokeStyle='#3a4367';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(xx,y0);ctx.lineTo(xx,y0+4);ctx.stroke();
        const parts=tickPartsForMode(t);
        ctx.save();ctx.translate(xx,y0+6);ctx.rotate(-Math.PI/6);ctx.textAlign='right';ctx.textBaseline='top';
        ctx.fillText(parts[0],0,0);ctx.fillText(parts[1],0,14);ctx.restore();
      }
      ctx.fillText(ymin.toFixed(3),x1-60,y0+16);
      ctx.fillText(ymax.toFixed(3),x1-60,y1-4);
    }

    function hexToRgb(hex){const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:{r:122,g:162,b:255};}
    function rgbToHex(r,g,b){return '#'+[r,g,b].map(v=>Math.max(0,Math.min(255,Math.round(v))).toString(16).padStart(2,'0')).join('');}
    function blend(c1,c2,t){const a=hexToRgb(c1),b=hexToRgb(c2);return rgbToHex(a.r+(b.r-a.r)*t,a.g+(b.g-a.g)*t,a.b+(b.b-a.b)*t);}
    function drawArrowhead(ctx,x,y,ang,size,color){ctx.save();ctx.translate(x,y);ctx.rotate(ang);ctx.fillStyle=color;ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(-size,size*0.6);ctx.lineTo(-size,-size*0.6);ctx.closePath();ctx.fill();ctx.restore();}

    function plotAngleVsDistance(canvas,dists,angles,markersPts,opts){
      const ctx=canvas.getContext('2d'); const W=canvas.width,H=canvas.height;
      ctx.clearRect(0,0,W,H);
      const P_LEFT=64,P_RIGHT=16,P_TOP=20,P_BOTTOM=50;
      const x0=P_LEFT,y0=H-P_BOTTOM,x1=W-P_RIGHT,y1=P_TOP;

      ctx.strokeStyle='#3a4367';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(x0,y0);ctx.lineTo(x1,y0);ctx.moveTo(x0,y0);ctx.lineTo(x0,y1);ctx.stroke();

      ctx.fillStyle='#9aa3c7';ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';
      ctx.fillText('Distance (AU)',(x0+x1)/2-40,y0+32);
      ctx.save();ctx.translate(x0-42,(y0+y1)/2+24);ctx.rotate(-Math.PI/2);ctx.fillText('Angle (deg)',0,0);ctx.restore();

      const xmin=Math.min(...dists),xmax=Math.max(...dists);
      const ymin=Math.min(...angles),ymax=Math.max(...angles);
      const xr=(xmax-xmin)||1,yr=(ymax-ymin)||1;
      const padX=xr*0.04,padY=yr*0.08;
      const minX=xmin-padX,maxX=xmax+padX,minY=ymin-padY,maxY=ymax+padY;
      const xmap=(x)=>x0+(x-minX)/(maxX-minX)*(x1-x0);
      const ymap=(y)=>y0-(y-minY)/(maxY-minY)*(y0-y1);

      ctx.strokeStyle='#25304f';ctx.setLineDash([3,3]);
      for(let i=1;i<=4;i++){const yy=y0-i*(y0-y1)/5;ctx.beginPath();ctx.moveTo(x0,yy);ctx.lineTo(x1,yy);ctx.stroke();}
      for(let i=1;i<=4;i++){const xx=x0+i*(x1-x0)/5;ctx.beginPath();ctx.moveTo(xx,y0);ctx.lineTo(xx,y1);ctx.stroke();}
      ctx.setLineDash([]);

      const useGradient=!!(opts&&opts.gradient);
      const showArrows=!!(opts&&opts.arrows);

      if(!useGradient){
        ctx.strokeStyle='#7aa2ff';ctx.lineWidth=2;ctx.beginPath();
        for(let i=0;i<dists.length;i++){const xx=xmap(dists[i]),yy=ymap(angles[i]);if(i===0)ctx.moveTo(xx,yy);else ctx.lineTo(xx,yy);}
        ctx.stroke();
      }else{
        ctx.lineWidth=2;
        for(let i=1;i<dists.length;i++){
          const t=i/(dists.length-1);ctx.strokeStyle=blend(CLR_TIME_EARLY,CLR_TIME_LATE,t);
          ctx.beginPath();ctx.moveTo(xmap(dists[i-1]),ymap(angles[i-1]));ctx.lineTo(xmap(dists[i]),ymap(angles[i]));ctx.stroke();
        }
      }

      ctx.fillStyle=useGradient?'#e8ecff33':'#7aa2ff';
      for(let i=0;i<dists.length;i++){const xx=xmap(dists[i]),yy=ymap(angles[i]);ctx.beginPath();ctx.arc(xx,yy,2,0,Math.PI*2);ctx.fill();}

      if(showArrows&&dists.length>1){
        const approx=120;let acc=0;
        for(let i=1;i<dists.length;i++){
          const xA=xmap(dists[i-1]),yA=ymap(angles[i-1]);
          const xB=xmap(dists[i]),yB=ymap(angles[i]);
          const dx=xB-xA,dy=yB-yA,len=Math.hypot(dx,dy);acc+=len;
          if(acc>=approx){acc=0;const ang=Math.atan2(dy,dx);
            const col=useGradient?blend(CLR_TIME_EARLY,CLR_TIME_LATE,i/(dists.length-1)):'#7aa2ff';
            drawArrowhead(ctx,xB,yB,ang,8,col);
          }
        }
      }

      if(markersPts&&markersPts.length){
        markersPts.forEach(m=>{
          const xx=xmap(m.x),yy=ymap(m.y);
          ctx.save();ctx.lineWidth=2;ctx.strokeStyle=m.color;ctx.fillStyle=m.color;
          ctx.beginPath();ctx.arc(xx,yy,5,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.restore();
        });
      }

      ctx.fillStyle='#9aa3c7';
      ctx.fillText(minX.toFixed(3),x0,y0+16);
      ctx.fillText(maxX.toFixed(3),x1-50,y0+16);
      ctx.fillText(minY.toFixed(3),x1-60,y0+16);
      ctx.fillText(maxY.toFixed(3),x1-60,y1-4);
    }

    function markerPointsForScatter(useTopo){
      const pts=[];
      const dtInput=$('dt').value; const center=dtInput?new Date(dtInput):new Date();
      const ttNow=new Astronomy.AstroTime(center);
      pts.push({ x:distanceAtTime(ttNow), y:angleAtTime(ttNow,useTopo), color:CLR_NOW });
      if(lastMarkers){
        [{t:lastMarkers.minAngleT,color:CLR_MIN},{t:lastMarkers.maxAngleT,color:CLR_MAX},{t:lastMarkers.minDistT,color:CLR_MIN_DIST},{t:lastMarkers.maxDistT,color:CLR_MAX_DIST}]
        .forEach(obj=>{const tt=new Astronomy.AstroTime(new Date(obj.t));pts.push({x:distanceAtTime(tt),y:angleAtTime(tt,useTopo),color:obj.color});});
      }
      return pts;
    }
    function currentScatterOpts(){
      return { arrows: $('chk-time-arrows')?.checked, gradient: $('chk-time-gradient')?.checked };
    }

    function replotAll(){
      const days=Math.max(1,parseInt($('scan-days').value)||30);
      const step=Math.max(1,parseInt($('scan-step').value)||6);
      const dtInput=$('dt').value;
      const center=dtInput?new Date(dtInput):new Date();
      const useTopo=$('chk-topo').checked;
      const s=collectSeries(center,days,step,useTopo);
      const markers=[{t:center.getTime(),color:CLR_NOW},...(lastMarkers?[{t:lastMarkers.minAngleT,color:CLR_MIN},{t:lastMarkers.maxAngleT,color:CLR_MAX},{t:lastMarkers.minDistT,color:CLR_MIN_DIST},{t:lastMarkers.maxDistT,color:CLR_MAX_DIST}]:[])];
      plotSeries($('chart-angle'),s.xs,s.angle,'Angular separation (deg) '+(useTopo?'(topocentric)':'(geocentric)'),markers);
      plotSeries($('chart-dist'), s.xs,s.dist, 'Distance (AU)', markers);
      plotAngleVsDistance($('chart-angle-dist'), s.dist, s.angle, markerPointsForScatter(useTopo), currentScatterOpts());
      setLegendTime(); setLegendScatter();
    }

    async function fetchElevationForInputs(silent=false){
      if(!silent)setErr('');
      const lat=parseFloat($('lat').value), lon=parseFloat($('lon').value);
      if(!Number.isFinite(lat)||!Number.isFinite(lon)){ if(!silent)setErr('Please enter valid latitude and longitude first.'); return; }
      const btn=$('btn-fetch-elev'); const old=btn.textContent; btn.disabled=true; btn.textContent='Fetching...';
      try{
        const url='https://api.open-meteo.com/v1/elevation?latitude='+encodeURIComponent(lat)+'&longitude='+encodeURIComponent(lon);
        const resp=await fetch(url); if(!resp.ok) throw new Error('HTTP '+resp.status);
        const data=await resp.json(); let elev=null;
        if(data && Array.isArray(data.elevation) && data.elevation.length>0) elev=data.elevation[0];
        else if(typeof data.elevation==='number') elev=data.elevation;
        if(elev==null||!Number.isFinite(elev)) throw new Error('No elevation in response');
        $('elev').value=Math.round(elev); updateObserverFromInputs(); compute();
      }catch(e){ if(!silent)setErr('Elevation lookup failed: '+e.message); }
      finally{ btn.disabled=false; btn.textContent=old; }
    }

    function useCurrentLocation(){
      setErr('');
      if(!('geolocation' in navigator)){ setErr('Geolocation not supported in this browser.'); return; }
      const btn=$('btn-my-location'); const old=btn.textContent; btn.disabled=true; btn.textContent='Locating...';
      navigator.geolocation.getCurrentPosition(async (pos)=>{
        try{
          const lat=pos.coords.latitude, lon=pos.coords.longitude;
          $('preset').value='custom'; $('lat').value=lat.toFixed(6); $('lon').value=lon.toFixed(6);
          $('elev').value=''; await fetchElevationForInputs(true);
          updateObserverFromInputs(); await fetchTimezoneForInputs(true); compute();
        } finally { btn.disabled=false; btn.textContent=old; }
      }, (err)=>{ setErr('Geolocation error: '+err.message); btn.disabled=false; btn.textContent=old; }, {enableHighAccuracy:true,timeout:10000,maximumAge:30000});
    }

    function setLegendTime(){ $('legend-time').innerHTML='Angle: <span class="min">Min</span>, <span class="max">Max</span> &nbsp;|&nbsp; Distance: <span class="min-dist">Min</span>, <span class="max-dist">Max</span> &nbsp;|&nbsp; <span class="now">Current Time</span>'; }
    function setLegendScatter(){
      const gradientOn=$('chk-time-gradient')?.checked;
      $('legend-scatter').innerHTML='<span class="swatch sw-path"></span> Path (time order)'+(gradientOn?' &nbsp;→ colored by time: <span class="swatch sw-grad-a"></span> early to <span class="swatch sw-grad-b"></span> late':' (solid blue)')+' &nbsp;|&nbsp; arrows show forward time (if enabled) &nbsp;|&nbsp; markers: <span class="swatch sw-now"></span> current time, <span class="swatch sw-min"></span> min angle, <span class="swatch sw-max"></span> max angle, <span class="swatch sw-mind"></span> min distance, <span class="swatch sw-maxd"></span> max distance';
    }

    /* ----------------- Init ----------------- */
    document.addEventListener('DOMContentLoaded', async ()=>{
      // Robust Back button
      (function(){
        var a=$('back');
        if(location.protocol==='http:'||location.protocol==='https:'){ a.href='https://abhlsd.com/ABHLSD.html'; }
        else { a.href='../ABHLSD.html'; }
      })();

      if(typeof window.Astronomy==='undefined'){ setErr('astronomy.browser.min.js did not load.'); }
      setInputsFromPreset('brisbane');
      await fetchTimezoneForInputs(true);
      setLegendTime(); setLegendScatter();

      $('preset').addEventListener('change',(e)=>{const val=e.target.value;if(val==='custom')return;setInputsFromPreset(val);});
      $('btn-update-observer').addEventListener('click',async()=>{updateObserverFromInputs();await fetchTimezoneForInputs(true);compute();});
      $('btn-fetch-elev').addEventListener('click',()=>fetchElevationForInputs(false));
      $('btn-my-location').addEventListener('click',useCurrentLocation);
      $('btn-now').addEventListener('click',()=>{setNow();compute();});
      $('btn-calc').addEventListener('click',compute);
      $('chk-topo').addEventListener('change',compute);

      $('chk-use-obs-tz').addEventListener('change',replotAll);
      ['chk-time-arrows','chk-time-gradient'].forEach(id=>{const el=$(id); if(el) el.addEventListener('change',()=>{replotAll(); setLegendScatter();});});

      $('btn-scan').addEventListener('click', async ()=>{
        setErr('');
        const days=Math.max(1,parseInt($('scan-days').value)||30);
        const step=Math.max(1,parseInt($('scan-step').value)||6);
        const dtInput=$('dt').value;
        const center=dtInput?new Date(dtInput):new Date();
        const useTopo=$('chk-topo').checked;
        const res=await scanExtrema(center,days,step,useTopo);

        lastMarkers={minAngleT:Date.parse(res.minAngle.time),maxAngleT:Date.parse(res.maxAngle.time),minDistT:Date.parse(res.minDistance.time),maxDistT:Date.parse(res.maxDistance.time)};

        if(!observerTz){ await fetchTimezoneForInputs(true); }
        const preferLocal=useObserverTz();
        const wrap=(label,content)=> preferLocal===(label==='local')?('<strong>'+content+'</strong>'):content;

        $('scan-results').innerHTML =
          '<span class="min-line">Closest (min) angular separation:   '+res.minAngle.deg.toFixed(6)+' deg</span><br/>' +
          '  • ' + wrap('utc',   'UTC: ' + res.minAngle.time) + '<br/>' +
          '  • ' + wrap('local', 'Local ('+(observerTzLabel||'')+'): ' + fmtInTz(res.minAngle.time, observerTz)) + '<br/>' +
          '<span class="max-line">Greatest (max) angular separation:  '+res.maxAngle.deg.toFixed(6)+' deg</span><br/>' +
          '  • ' + wrap('utc',   'UTC: ' + res.maxAngle.time) + '<br/>' +
          '  • ' + wrap('local', 'Local ('+(observerTzLabel||'')+'): ' + fmtInTz(res.maxAngle.time, observerTz)) + '<br/>' +
          '<span class="min-dist-line">Closest (min) distance:  '+res.minDistance.au.toFixed(6)+' AU ('+res.minDistance.km.toLocaleString()+' km)</span><br/>' +
          '  • ' + wrap('utc',   'UTC: ' + res.minDistance.time) + '<br/>' +
          '  • ' + wrap('local', 'Local ('+(observerTzLabel||'')+'): ' + fmtInTz(res.minDistance.time, observerTz)) + '<br/>' +
          '<span class="max-dist-line">Greatest (max) distance: '+res.maxDistance.au.toFixed(6)+' AU ('+res.maxDistance.km.toLocaleString()+' km)</span><br/>' +
          '  • ' + wrap('utc',   'UTC: ' + res.maxDistance.time) + '<br/>' +
          '  • ' + wrap('local', 'Local ('+(observerTzLabel||'')+'): ' + fmtInTz(res.maxDistance.time, observerTz)) + '<br/>' +
          '(Times refined to ~10 seconds; tick labels respect the timezone toggle)';

        replotAll();
      });

      $('btn-plot').addEventListener('click',()=>{ setErr(''); replotAll(); });

      function saveCanvasAsPng(canvas,filename){const link=document.createElement('a');link.download=filename;link.href=canvas.toDataURL('image/png');document.body.appendChild(link);link.click();document.body.removeChild(link);}
      function downloadText(filename,text){const blob=new Blob([text],{type:'text/plain'});const url=URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download=filename;document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(url);}

      $('btn-save-png').addEventListener('click',()=>{replotAll();const stamp=new Date().toISOString().replace(/[:.]/g,'-');saveCanvasAsPng($('chart-angle'),'angle_'+stamp+'.png');saveCanvasAsPng($('chart-dist'),'distance_'+stamp+'.png');saveCanvasAsPng($('chart-angle-dist'),'angle_vs_distance_'+stamp+'.png');});

      $('btn-download-csv').addEventListener('click',()=>{
        const days=Math.max(1,parseInt($('scan-days').value)||30);
        const step=Math.max(1,parseInt($('scan-step').value)||6);
        const dtInput=$('dt').value; const center=dtInput?new Date(dtInput):new Date();
        const useTopo=$('chk-topo').checked;
        const s=collectSeries(center,days,step,useTopo);
        let csv='time_iso,angle_deg('+(useTopo?'topocentric':'geocentric')+'),distance_au,distance_km\n';
        for(let i=0;i<s.xs.length;i++){
          const iso=new Date(s.xs[i]).toISOString();
          const ang=s.angle[i]; const au=s.dist[i]; const km=au*AU_KM;
          csv+=iso+','+ang.toFixed(8)+','+au.toFixed(8)+','+Math.round(km)+'\n';
        }
        const stamp=new Date().toISOString().replace(/[:.]/g,'-');
        downloadText('mars_venus_scan_'+stamp+'.csv',csv);
      });

      setNow(); compute();
    });
  })();
  </script>
</body>
</html>
